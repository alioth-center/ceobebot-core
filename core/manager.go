package core

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"

	"github.com/alioth-center/infrastructure/config"
	"github.com/alioth-center/infrastructure/logger"
	"github.com/alioth-center/infrastructure/trace"
	"github.com/sirupsen/logrus"
	zero "github.com/wdvxdr1123/ZeroBot"
	"github.com/wdvxdr1123/ZeroBot/driver"
	"gopkg.in/yaml.v3"
)

var (
	coreLogger logger.Logger
	tempLogger logger.Logger

	coreConfig      = &Config{}
	pluginConfigMap = map[string]*PluginConfig{}
)

// Logger return the logger for core
func Logger() logger.Logger {
	return coreLogger
}

// SetLogger set the logger for core, only set once when the logger is 'custom'
func SetLogger(log logger.Logger) {
	if log != nil && tempLogger == nil {
		tempLogger = log
	}
}

func Initialize() (ctx context.Context, cfg *Config, mapping map[string]*PluginConfig) {
	ctx = trace.NewContext()

	initPackage()
	initializeCore(ctx)
	loadConfigs(ctx)

	return ctx, coreConfig, pluginConfigMap
}

func initPackage() {
	// testing mode, skip initialization
	if os.Getenv("ci") == "true" {
		return
	}

	// config not found, created default config
	configPath := filepath.Join("./config", "bot.yaml")
	if _, statErr := os.Stat(configPath); errors.Is(statErr, os.ErrNotExist) {
		_ = os.MkdirAll(filepath.Dir(configPath), os.ModePerm)
		outBytes, _ := yaml.Marshal(&Config{
			Bot: BotConfig{
				Nickname:      []string{"小刻"},
				TriggerPrefix: "",
				SupperUsers:   []int64{1145141919},
				Logger:        "file",
			},
			Websocket: WebsocketConfig{
				Host:        "",
				Port:        0,
				AccessToken: "",
			},
			Plugins: []PluginConfig{
				{
					Name:           "",
					Description:    "",
					Help:           "",
					Enable:         false,
					Banner:         "",
					ConfigFile:     "",
					ResourceFolder: "",
					DataFolder:     "",
					Priority:       0,
					Middlewares:    MiddlewareConfig{},
					Handlers:       nil,
				},
			},
		})
		f, _ := os.Create(configPath)
		_, _ = f.WriteString("# this configuration is generated by ceobebot, please modify it according to your needs\n")
		_, _ = f.Write(outBytes)
		panic("config file not found, initialized, please configure it and retry")
	}

	// read core config
	loadErr := config.LoadConfig(coreConfig, configPath)
	if loadErr != nil {
		panic("failed to load core config: " + loadErr.Error())
	}

	// register default rules and limiters
	initRegister()
}

func initializeCore(ctx context.Context) {
	// debug mode specific logger
	if coreConfig.Bot.Debug {
		coreConfig.Bot.Logger = "custom"
		SetLogger(logger.NewLoggerWithConfig(logger.Config{
			Level:          "debug",
			Formatter:      "json",
			StdoutFilePath: "",
			StderrFilePath: "/dev/null",
		}))
	}

	// init logger
	switch coreConfig.Bot.Logger {
	case "custom":
		if tempLogger == nil {
			tempLogger = logger.New()
		}

		coreLogger = tempLogger
	case "console":
		coreLogger = logger.New()
	case "file":
		// check log file directory exists
		if _, checkLogDirErr := os.Stat("./logs"); os.IsNotExist(checkLogDirErr) {
			mkdirLogDirErr := os.Mkdir("./logs", os.ModePerm)
			if mkdirLogDirErr != nil {
				panic("failed to create log directory: " + mkdirLogDirErr.Error())
			}
		}
		coreLogger = logger.NewLoggerWithConfig(logger.Config{Level: "info", Formatter: "json", StdoutFilePath: "./logs/stdout.log", StderrFilePath: "./logs/stderr.log"})
	default:
		// default log to console
		coreLogger = logger.New()
	}

	defer coreLogger.Info(logger.NewFields(ctx).WithMessage("core initialized"))

	// mute zero framework logger
	if !coreConfig.Bot.Debug {
		logrus.SetLevel(logrus.PanicLevel)
	}

	// init zero config and websocket driver
	websocketClient := &driver.WSClient{
		Url:         fmt.Sprintf("ws://%s:%d", coreConfig.Websocket.Host, coreConfig.Websocket.Port),
		AccessToken: coreConfig.Websocket.AccessToken,
	}
	coreConfig.ZeroConfig = &zero.Config{
		NickName:      coreConfig.Bot.Nickname,
		CommandPrefix: coreConfig.Bot.TriggerPrefix,
		SuperUsers:    coreConfig.Bot.SupperUsers,
		Driver:        []zero.Driver{websocketClient},
	}

	// mapping plugin config
	for _, plugin := range coreConfig.Plugins {
		if !plugin.Enable {
			// skip disabled plugin
			continue
		}

		if _, existPlugin := pluginConfigMap[plugin.Name]; existPlugin {
			// cannot have duplicate plugin name, it will replace another plugin implementation
			panic("duplicate plugin name: " + plugin.Name)
		}

		pluginConfigMap[plugin.Name] = &plugin
	}
}

func loadConfigs(ctx context.Context) {
	for _, plugin := range pluginConfigMap {
		if !plugin.Enable || plugin.ConfigFile == "" {
			// skip disabled plugin
			continue
		}

		// load plugin config
		loadConfig(plugin)
		coreLogger.Debug(logger.NewFields(ctx).WithMessage("plugin config loaded").WithData(map[string]any{"plugin": plugin.Name}))
	}
}
